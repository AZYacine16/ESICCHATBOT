// src/app/api/chat/route.ts
import { NextResponse } from "next/server";
import { v4 as uuidv4 } from "uuid";
export const runtime = "nodejs";
import {
  validateSession,
  findBestAnswer,
  appendLog,
  normalize,
} from "@/lib/db";

/**
 * SCRUM-17 + US-013:
 * - detectInjection(input): basic regex-based detector (XSS / SQLi / JS)
 * - securityAttempts: in-memory counter per key (IP or user) to detect repeated attempts (SCRUM-17)
 * - rateLimiter: per-user timestamps + ban map for US-013
 *
 * NOTE: in production, remplacez les Maps en m√©moire par Redis (persistance & scale).
 */

// ---------------------- Injection detection (SCRUM-17) ----------------------
function detectInjection(input: string): {
  detected: boolean;
  pattern?: string;
} {
  if (!input || typeof input !== "string") return { detected: false };

  const patterns: { name: string; re: RegExp }[] = [
    { name: "xss_script_tag", re: /<script\b[^>]*>([\s\S]*?)<\/script>/i },
    { name: "xss_event_handler", re: /on\w+\s*=/i },
    { name: "xss_img_onerror", re: /<img\b[^>]*onerror\s*=/i },
    { name: "js_eval", re: /\beval\s*\(/i },
    { name: "js_fetch_xhr", re: /\b(fetch|XMLHttpRequest)\b/i },
    { name: "sqli_union_select", re: /\bunion\b[\s\S]*\bselect\b/i },
    {
      name: "sqli_tautology",
      re: /(['"`]).*?\1\s*or\s+['"`]?.*?['"`]?\s*=\s*['"`]?.*?['"`]?/i,
    },
    {
      name: "sqli_drop",
      re: /\b(drop|delete|insert|update|alter)\b\s+table\b/i,
    },
    { name: "sql_semicolon", re: /;.*\b(drop|select|insert|delete|update)\b/i },
    {
      name: "suspicious_chars_keywords",
      re: /(<\/?\w+[^>]*>)|(--\s*$)|(\b(alert|prompt|onerror|onload|exec|system)\b)/i,
    },
  ];

  for (const p of patterns) {
    if (p.re.test(input)) {
      return { detected: true, pattern: p.name };
    }
  }
  return { detected: false };
}

// ---------------------- Security attempts counting (SCRUM-17) ----------------------
const securityAttempts = new Map<
  string,
  { count: number; firstTs: number; lastTs: number }
>();
const ATTEMPT_WINDOW_MS = 10 * 60 * 1000; // 10 minutes default
const ATTEMPT_THRESHOLD = 5;

// ---------------------- Rate limiting (US-013) ----------------------
// Config via env vars (modifiable)
const RATE_LIMIT_WINDOW_MS = process.env.RATE_LIMIT_WINDOW_MS
  ? Number(process.env.RATE_LIMIT_WINDOW_MS)
  : 60 * 60 * 1000; // default: 1 heure

const RATE_LIMIT_MAX = process.env.RATE_LIMIT_MAX
  ? Number(process.env.RATE_LIMIT_MAX)
  : 10; // default: 10 questions / fen√™tre

const RATE_LIMIT_BAN_MS = process.env.RATE_LIMIT_BAN_MS
  ? Number(process.env.RATE_LIMIT_BAN_MS)
  : 30 * 60 * 1000; // default: 30 minutes

// Per-user timestamps (in-memory)
const rateMap = new Map<string, number[]>(); // key = user:<id> => array of epoch ms
// Per-user temporary ban map
const banMap = new Map<string, number>(); // key = user:<id> => banExpiryEpochMs

// ---------------------- POST handler ----------------------
export async function POST(req: Request) {
  try {
    // Auth guard
    const cookies = req.headers.get("cookie") || "";
    const sessionId = cookies.split("sid=")[1]?.split(";")[0];

    if (!sessionId) {
      return NextResponse.json({ error: "Non authentifi√©" }, { status: 401 });
    }

    // Dev helper: allow sid=test-session-1 => user 1 (seeded)
    let session: any = null;
    if (
      process.env.NODE_ENV !== "production" &&
      sessionId === "test-session-1"
    ) {
      session = { user_id: 1 };
    } else {
      session = validateSession(sessionId);
    }

    if (!session) {
      return NextResponse.json({ error: "Session invalide" }, { status: 401 });
    }

    const { question, chatId: incomingChatId } = await req.json();
    if (!question) {
      return NextResponse.json({ error: "Question vide" }, { status: 400 });
    }

    const ip =
      req.headers.get("x-forwarded-for") ||
      req.headers.get("x-real-ip") ||
      "unknown";
    const userAgent = req.headers.get("user-agent") || "unknown";
    const userKey = `user:${session.user_id}`;

    // ---------------------- Injection detection (SCRUM-17) ----------------------
    const detection = detectInjection(question);
    if (detection.detected) {
      const secChatId = incomingChatId || uuidv4();
      const timestamp = new Date().toISOString();
      const pattern = detection.pattern || "unknown";
      const truncated =
        question.length > 200 ? question.slice(0, 200) + "..." : question;
      const secText = `[SECURITY ALERT] Tentative d'injection d√©tect√©e (${pattern}) : ${truncated}`;

      console.log("[SEC-DETECT] will appendLog (security)", {
        chatId: secChatId,
        userId: session.user_id,
        role: "security",
        pattern,
        ip,
        userAgent,
        truncated: truncated.slice(0, 200),
      });

      try {
        appendLog({
          chatId: secChatId,
          userId: session.user_id || 0,
          role: "security",
          text: secText,
          matched: false,
          timestamp,
          ip,
        });
        console.log("[SEC-DETECT] appendLog (security) called successfully");
      } catch (err) {
        console.error("[SEC-DETECT] appendLog error:", err);
      }

      // increment SCRUM-17 securityAttempts
      const key = ip !== "unknown" ? `ip:${ip}` : `user:${session.user_id}`;
      const now = Date.now();
      const prev = securityAttempts.get(key);
      if (!prev || now - prev.firstTs > ATTEMPT_WINDOW_MS) {
        securityAttempts.set(key, { count: 1, firstTs: now, lastTs: now });
      } else {
        prev.count += 1;
        prev.lastTs = now;
        securityAttempts.set(key, prev);
        if (prev.count >= ATTEMPT_THRESHOLD) {
          const alertText = `[SECURITY ALERT] Seuil atteint (${prev.count}) pour ${key}. Action recommand√©e: bannissement temporaire ou investigation.`;
          try {
            appendLog({
              chatId: secChatId,
              userId: session.user_id || 0,
              role: "security",
              text: alertText,
              matched: false,
              timestamp: new Date().toISOString(),
              ip,
            });
          } catch (err) {
            console.error("[SEC-DETECT] appendLog threshold error:", err);
          }
        }
      }

      return NextResponse.json(
        { error: "Requ√™te invalide d√©tect√©e." },
        { status: 400 }
      );
    }

    // ---------------------- Rate limiting (US-013) ----------------------
    // Check ban first
    const banExpiry = banMap.get(userKey);
    const now = Date.now();
    if (banExpiry && banExpiry > now) {
      const remainingMin = Math.ceil((banExpiry - now) / 60000);
      const message = `Vous avez atteint la limite de questions. R√©essayez dans ${remainingMin} minute(s).`;
      console.log("[RATE] user blocked", { userKey, banExpiry });
      // Log the blocked attempt
      try {
        appendLog({
          chatId: incomingChatId || uuidv4(),
          userId: session.user_id || 0,
          role: "security",
          text: `[RATE LIMIT BLOCKED] Tentative alors que user est banni jusqu'√† ${new Date(
            banExpiry
          ).toISOString()}`,
          matched: false,
          timestamp: new Date().toISOString(),
          ip,
        });
      } catch (err) {
        console.error("[RATE] appendLog blocked attempt error:", err);
      }
      return NextResponse.json({ error: message }, { status: 429 });
    }

    // get timestamps array for user and prune older than window
    const windowStart = now - RATE_LIMIT_WINDOW_MS;
    const arr = rateMap.get(userKey) || [];
    const pruned = arr.filter((ts) => ts > windowStart);
    pruned.push(now);

    // store back pruned array
    rateMap.set(userKey, pruned);

    if (pruned.length > RATE_LIMIT_MAX) {
      // Exceeded limit -> apply temporary ban
      const banUntil = now + RATE_LIMIT_BAN_MS;
      banMap.set(userKey, banUntil);

      const humanMsg = `Vous avez atteint la limite de questions. R√©essayez dans ${Math.ceil(
        RATE_LIMIT_BAN_MS / 60000
      )} minutes.`;
      console.log("[RATE] limit exceeded, banning user", {
        userKey,
        banUntil,
        count: pruned.length,
      });

      // Log the exceeded attempt with required info: user ID, timestamp, IP
      try {
        appendLog({
          chatId: incomingChatId || uuidv4(),
          userId: session.user_id || 0,
          role: "security",
          text: `[RATE LIMIT EXCEEDED] user=${session.user_id} count=${pruned.length} window_ms=${RATE_LIMIT_WINDOW_MS}`,
          matched: false,
          timestamp: new Date().toISOString(),
          ip,
        });
      } catch (err) {
        console.error("[RATE] appendLog exceed error:", err);
      }

      return NextResponse.json({ error: humanMsg }, { status: 429 });
    }

    // ---------------------- Normal processing ----------------------
    const q = normalize(question);
    const chatId = incomingChatId || uuidv4();

    // directAnswers (unchanged)
    const directAnswers: Record<string, string> = {
      "horaires bibliotheque":
        "üìö La biblioth√®que est ouverte du lundi au vendredi de 8h √† 18h.",
      "horaires resto u":
        "üçΩÔ∏è Le restaurant universitaire est ouvert de 11h30 √† 14h et de 18h30 √† 20h.",
      "contact scolarite": "CONTACT_SCOLARITE",
      "regles de vie": `
üìò Voici les principales <b>r√®gles de vie du campus</b> :<br/><br/>
‚úÖ Respecter les horaires et les salles attribu√©es.<br/>
üö≠ Interdiction de fumer dans les b√¢timents.<br/>
ü§ù Respect mutuel entre √©tudiants et enseignants.<br/>
üíª Utilisation responsable des ressources num√©riques.<br/><br/>
üëâ Le <b>r√®glement int√©rieur complet</b> est disponible sur <b>Teams</b>, dans la classe :<br/>
<em>ESIS-2_CPDIA-2_2025-2026</em>.`,
      "reglement campus": "regles de vie",
      reglement: "regles de vie",
      "r√®gles de vie": "regles de vie",
      "charte de bonne conduite": "regles de vie",
      "consignes de s√©curit√©": "regles de vie",
      "dates importantes": `
üóìÔ∏è Voici les prochaines <b>dates importantes</b> du calendrier acad√©mique :<br/><br/>
üìÖ <b>Rentr√©e universitaire :</b> 22 septembre 2025<br/>
üìù <b>D√©but des examens du semestre 1 :</b> 19 janvier 2025<br/>
üìÖ <b>Journ√©e Portes Ouvertes :</b> 15 mars 2025<br/>
üå∏ <b>Vacances de printemps :</b> 20 avril ‚Üí 04 mai 2025<br/>
üéì <b>Fin des cours du semestre 2 :</b> 30 juin 2025<br/>
‚òÄÔ∏è <b>Vacances d‚Äô√©t√© :</b> √† partir du 1er juillet 2025`,
      examens:
        "üìù Les examens du semestre 1 d√©butent le <b>19 janvier 2025</b>.",
      vacances: "‚òÄÔ∏è Les vacances d'√©t√© commencent le <b>1er juillet 2025</b>.",
      "formations proposees": `
üéì L‚ÄôESIC propose plusieurs formations en <b>informatique</b> et en <b>commerce</b> :<br/><br/>
... (omitted for brevity)`,
      formations: "formations proposees",
      formation: "formations proposees",
      bts: "formations proposees",
      master: "formations proposees",
      informatique: "formations proposees",
      commerce: "formations proposees",
      programmes: "formations proposees",
    };

    // find answer
    let found = directAnswers[q];
    if (found && directAnswers[found]) found = directAnswers[found];
    if (!found) found = findBestAnswer(q);
    const response = found || "Je n'ai pas encore la r√©ponse √† cette question.";

    // save question log (user)
    try {
      appendLog({
        chatId,
        userId: session.user_id,
        role: "user",
        text: question,
        matched: 1,
        timestamp: new Date().toISOString(),
        ip,
      });
    } catch (err) {
      console.error("appendLog(user) failed:", err);
    }

    // save assistant log
    try {
      appendLog({
        chatId,
        userId: session.user_id,
        role: "assistant",
        text: response,
        matched: Boolean(found),
        timestamp: new Date().toISOString(),
        ip: "server",
      });
    } catch (err) {
      console.error("appendLog(assistant) failed:", err);
    }

    return NextResponse.json({ answer: response, chatId });
  } catch (e) {
    console.error("Erreur chat:", e);
    return NextResponse.json({ error: "Erreur serveur" }, { status: 500 });
  }
}
